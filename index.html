<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Valentine</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&family=Patrick+Hand&display=swap" rel="stylesheet">
<link href="https://fonts.googleapis.com/css2?family=Quicksand:wght@400;600&display=swap" rel="stylesheet">

<style>
/* ===== BASE ===== */
body{
  margin:0;
  font-family:'Poppins',sans-serif;
  background:
    linear-gradient(rgba(255,230,238,0.75),rgba(255,230,238,0.75)),
    url("bg.jpg") center/cover no-repeat;
  overflow-x:hidden;
}

/* paper grain */
body::after{
  content:"";
  position:fixed;
  inset:0;
  background:repeating-linear-gradient(
    0deg,
    rgba(0,0,0,0.02),
    rgba(0,0,0,0.02) 1px,
    transparent 1px,
    transparent 3px
  );
  pointer-events:none;
}

/* ===== SCREEN + BOX ===== */
.screen{
  min-height:100vh;
  display:flex;
  justify-content:center;
  align-items:center;
  text-align:center;
  padding:20px;
}

.box{
  max-width:650px;
  background:linear-gradient(145deg,#ffd6e6,#ffeaf2);
  padding:32px 38px;
  border-radius:20px;
  box-shadow:0 25px 60px rgba(233,120,150,0.35);
  backdrop-filter: blur(6px);
  border:1px solid rgba(255,255,255,0.6);
  position:relative;
  overflow:visible;
}
  .box-image{
  width:100%;
  height:auto;              /* keeps original proportions */
  max-height:60vh;          /* prevents going off screen */
  object-fit:contain;       /* no cropping */
  display:block;
  margin: -20px auto 20px;  /* pulls slightly outside box top */
  border-radius:18px;
}
 @media (max-width:600px){
  .box-image{ max-height:45vh; }
}

button{
  padding:12px 26px;
  border:none;
  border-radius:25px;
  background:#e88aa5;
  color:white;
  font-size:16px;
  cursor:pointer;
  margin:10px;
}
button:hover{background:#c94b6a}
.no{background:#ffdbe6;color:#444;position:relative}

/* ===== MEMORY LANE ===== */
.memory-wrapper{
  width:100%;
  max-width:900px;
  margin:0 auto;
  display:flex;
  flex-direction:column;
  gap:80px;
  padding:80px 20px;
}

/* ===== PINK TORN PAPER CARD ===== */
.memory-card{
  position:relative;
  max-width:320px;
  align-self:center;
  background:linear-gradient(145deg,#ffd1e3,#ffe6f0);
  padding:18px 18px 26px;
  border-radius:18px;
  box-shadow:
    0 20px 40px rgba(232,120,165,0.35),
    inset 0 0 0 2px rgba(255,255,255,0.5);

  clip-path: polygon(
    0% 4%, 4% 0%, 96% 0%, 100% 4%,
    100% 96%, 96% 100%, 4% 100%, 0% 96%
  );

  opacity:0;
  transform:translateY(60px) scale(0.9);
  transition:all 0.9s cubic-bezier(.18,.89,.32,1.28);
}

/* torn edge illusion */
.memory-card::before{
  content:"";
  position:absolute;
  inset:-6px;
  background:
    radial-gradient(circle at 10% 20%,transparent 12px,#ffd1e3 13px),
    radial-gradient(circle at 90% 80%,transparent 10px,#ffd1e3 11px);
  z-index:-1;
  opacity:0.6;
}

/* image */
.memory-card img{
  width:100%;
  border-radius:12px;
  display:block;
}

/* handwritten text */
.memory-text{
  font-family:'Quicksand', sans-serif;
  text-align:center;
  margin-top:14px;
  font-size:23px;
  line-height:1.55;
  color:#6a1b3f;
}

/* animate in */
.memory-card.show{
  opacity:1;
  transform:translateY(0) scale(1);
}

/* zig-zag scrapbook */
.memory-card:nth-child(odd){
  align-self:flex-start;
}
.memory-card:nth-child(even){
  align-self:flex-end;
}

/* fade out */
.fade-out{
  opacity:0!important;
  transform:scale(0.6) translateY(-40px);
}

/* ===== STICKERS ===== */
.sticker{
  position:fixed;
  font-size:36px;
  animation:pop .6s ease;
}
@keyframes pop{
  from{transform:scale(0)}
  to{transform:scale(1)}
}

/* ===== HEARTS ===== */
.heart{
  position:fixed;
  bottom:-20px;
  font-size:22px;
  animation:float 4s linear infinite;
}
@keyframes float{
  to{transform:translateY(-100vh);opacity:0}
}
  /* Add this new rule for button row layout */
.btnRow{
  display:flex;
  justify-content:center;
  gap:20px;
  margin-top:20px;
}

/* Adjust the "no" button styling */
.no{
  background:#f5a9c4;
  color:white;
  position:relative;   /* start aligned normally */
}
.playing-indicator {
  display:inline-block;
  width:10px;
  height:10px;
  margin-left:8px;
  border-radius:50%;
  background:#e88aa5;
  box-shadow:0 0 8px rgba(232,138,165,0.9);
  vertical-align:middle;
  animation: pulse 1s infinite;
  opacity:0;
  transition:opacity .2s;
}
.playing-indicator.visible { opacity:1; }
@keyframes pulse {
  0% { transform:scale(1); }
  50% { transform:scale(1.25); }
  100% { transform:scale(1); }
}
/* ===== Copilot extensions: floating decorations + scroll hint ===== */
/* Floating side decorations (left and right) */
.cp-float-deco {
  position: fixed;
  top: 30%;
  width: 18px;
  height: 18px;
  border-radius: 50%;
  background: linear-gradient(135deg,#ffd6e6,#ffeaf2);
  box-shadow: 0 6px 18px rgba(233,120,150,0.18);
  pointer-events: none;
  opacity: 0.95;
  z-index: 999; /* above content but below UI modals */
  transform: translateY(0);
  will-change: transform, opacity;
  animation: cp-deco-float 6s ease-in-out infinite;
}

/* Slight size/opacity variation for visual interest */
.cp-float-deco.cp-small { width:12px; height:12px; opacity:0.85; }
.cp-float-deco.cp-large { width:22px; height:22px; opacity:1; }

/* Left and right anchors */
.cp-float-left  { left: 12px; }
.cp-float-right { right: 12px; }

/* Gentle float animation */
@keyframes cp-deco-float {
  0%   { transform: translateY(0) translateX(0) rotate(0deg); }
  50%  { transform: translateY(-18px) translateX(4px) rotate(6deg); }
  100% { transform: translateY(0) translateX(0) rotate(0deg); }
}

/* Scroll hint container near bottom center */
.cp-scroll-hint {
  position: fixed;
  left: 50%;
  transform: translateX(-50%) translateY(0);
  bottom: 28px;
  background: rgba(255,255,255,0.92);
  color: #6a1b3f;
  font-family: 'Patrick Hand', cursive;
  font-size: 16px;
  padding: 10px 14px;
  border-radius: 22px;
  box-shadow: 0 8px 24px rgba(233,120,150,0.12);
  z-index: 1000;
  pointer-events: none; /* must not block clicks */
  opacity: 1;
  transition: opacity 420ms ease, transform 420ms cubic-bezier(.18,.89,.32,1.28);
  display: flex;
  align-items: center;
  gap: 8px;
}

/* small heart icon inside hint */
.cp-scroll-hint .cp-hint-heart {
  font-size: 18px;
  transform-origin: center;
  display:inline-block;
  animation: cp-heart-pulse 1.2s ease-in-out infinite;
}

/* soft pulsing / bouncing of the whole hint */
@keyframes cp-heart-pulse {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.12); }
  100% { transform: scale(1); }
}

/* subtle up/down bounce for the hint container */
@keyframes cp-hint-bounce {
  0%   { transform: translateX(-50%) translateY(0); }
  50%  { transform: translateX(-50%) translateY(-8px); }
  100% { transform: translateX(-50%) translateY(0); }
}
.cp-scroll-hint.cp-bounce { animation: cp-hint-bounce 2.2s ease-in-out infinite; }

/* Hidden state after user scrolls */
.cp-hidden {
  opacity: 0 !important;
  transform: translateX(-50%) translateY(8px) !important;
  pointer-events: none !important;
}

/* Accessibility: reduce motion respects */
@media (prefers-reduced-motion: reduce) {
  .cp-float-deco, .cp-scroll-hint { animation: none !important; transition: none !important; }
}
</style>

</head>

<body>
<audio id="music" src="bg-music.mp3" loop preload="auto" playsinline crossorigin="anonymous"></audio>
<div id="app"></div>
<script>
const app = document.getElementById("app");
const music = document.getElementById("music");

function render(h){ app.innerHTML = h; }

/* ===== Web Audio fade-in helpers ===== */
let audioCtx = null;
let sourceNode = null;
let gainNode = null;
const targetVolume = 0.35;
const fadeDuration = 1.2; // seconds

function initAudioNodes() {
  if (audioCtx) return true;
  try {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    sourceNode = audioCtx.createMediaElementSource(music);
    gainNode = audioCtx.createGain();
    gainNode.gain.value = 0;
    sourceNode.connect(gainNode).connect(audioCtx.destination);
    return true;
  } catch (e) {
    audioCtx = null;
    gainNode = null;
    return false;
  }
}

function startMusicFadeIn() {
  if (music._fadingStarted) return;
  music._fadingStarted = true;

  const hasWebAudio = initAudioNodes();

  if (audioCtx && audioCtx.state === 'suspended') {
    audioCtx.resume().catch(()=>{});
  }

  music.currentTime = 0;
  music.play().catch(()=>{});

  const indicator = document.querySelector(".playing-indicator");
  if (indicator) indicator.classList.add("visible");

  if (hasWebAudio && gainNode) {
    const now = audioCtx.currentTime;
    gainNode.gain.cancelScheduledValues(now);
    gainNode.gain.setValueAtTime(0, now);
    gainNode.gain.linearRampToValueAtTime(targetVolume, now + fadeDuration);
  } else {
    music.volume = 0;
    let v = 0;
    const steps = Math.max(1, Math.floor(fadeDuration * 30));
    const stepInc = targetVolume / steps;
    const stepMs = (fadeDuration * 1000) / steps;
    const f = setInterval(() => {
      v = Math.min(targetVolume, v + stepInc);
      music.volume = v;
      if (v >= targetVolume) clearInterval(f);
    }, stepMs);
  }
}

/* ===== Utilities from your original code ===== */
function typeWriter(text,id,speed=35){
  let i=0;
  const el=document.getElementById(id);
  const t=setInterval(()=>{
    el.textContent+=text[i++];
    if(i>=text.length) clearInterval(t);
  },speed);
}

function popSticker(){
  const s=document.createElement("div");
  s.className="sticker";
  s.innerText="ðŸ’—";
  s.style.left=Math.random()*80+"vw";
  s.style.top=Math.random()*80+"vh";
  document.body.appendChild(s);
  setTimeout(()=>s.remove(),1000);
}

/* ===== Your slides and flow (unchanged except startMem) ===== */
render(`
<div class="screen"><div class="box">
<p>Ok, Sooo, valentine wale chochle hume jyada samajh ni aate,<br>cheesy lagte, right?</p>
<button onclick="slide2()">right</button>
<button onclick="alert('tum toh potty ho, try again')">naah</button>
</div></div>`);

function slide2(){
  render(`<div class="screen"><div class="box">
  <p>Ek saal pehle tak relationship bf-gf bhi bakchodi lagti thi, haina?</p>
  <button onclick="slide3()">right</button>
  <button onclick="alert('tum toh geeli wali potti ho, gandmastii mat karo')">naah</button>
  </div></div>`);
}

function slide3(){
  render(`
    <div class="screen">
      <div class="box">

        <img src="pic7.jpg" class="box-image">

        <p id="typeSlide3"></p>

        <button onclick="startMem()">convince me more</button>

      </div>
    </div>
  `);

  typeWriter(`but look where we stand today...

You stayed. Not just on the good days.
We survived the messy days too.
Mostly playing around, being goofy ðŸ’—`,"typeSlide3");
}

/* MEMORIES data unchanged */
const pics=["pic1.jpg","pic2.jpg","pic3.jpg","pic4.jpg","pic5.jpg","pic6.jpg"];
const texts=[
"kha lugi mac Donald domino zindagibhar tumhare sath, pakki par nakhre obvious",
"kaat lugi puri Zindagi metro station p tere sang, tu chahe toh",
"Humesha ghusugi tumhare personal space me hehe",
"iss din ki trh har din khush rakhne ki koshish rahegi jaan",
"boht pasand hai tumhare kandhe pe sar rakhna",
"sath m cheeziya khana bhi boht pasand hai yaaar"
];

let i=0;

/* ===== REPLACED startMem to start music immediately after click ===== */
function startMem(){
  // create and show a tiny indicator next to the button row
  if (!document.querySelector(".playing-indicator")) {
    const ind = document.createElement("span");
    ind.className = "playing-indicator";
    const btnRow = document.querySelector(".btnRow") || document.body;
    btnRow.appendChild(ind);
  }

  // start music immediately after the user click (user gesture)
  startMusicFadeIn();

  // then render memories as before
  render(`<div class="screen"><div class="memory-wrapper" id="mem"></div></div>`);
  i = 0; // reset index so memories replay from start
  showMem();
}

function showMem(){
  if(i>=pics.length){
    setTimeout(fadeMemories,1500);
    return;
  }

  popSticker();

  const mem=document.getElementById("mem");
  const card=document.createElement("div");
  card.className="memory-card";
  card.style.zIndex=i;

  card.style.transform = `rotate(${Math.random()*6-3}deg)`;

  card.innerHTML = `
    <img src="${pics[i]}">
    <div class="memory-text">${texts[i]}</div>
  `;

  mem.appendChild(card);
  setTimeout(()=>card.classList.add("show"),100);

  i++;
  setTimeout(showMem,3000);
}

function fadeMemories(){
  document.querySelectorAll(".memory-card").forEach(c=>c.classList.add("fade-out"));

  setTimeout(()=>{
    render(`
      <div class="screen">
        <div class="box">
          <h2 id="loveLine"></h2>

          <div class="btnRow">
            <button onclick="finalScreen()">true true</button>
            <button id="noLoveBtn">no</button>
          </div>

        </div>
      </div>
    `);

    typeWriter("Yeh sab dheere dheere buna hai pyaar ke sath â¤ï¸","loveLine",40);

    document.getElementById("noLoveBtn").addEventListener("click",()=>{
      alert("abe chup be lawdeya");
    });

  },1200);
}

/* FINAL and yes/no logic unchanged */
function finalScreen(){
  render(`
    <div class="screen">
      <div class="box" id="finalBox">

        <p>soooo, will you be my valentine,<br><b>Krish Sharma?</b></p>

        <div class="btnRow">
          <button id="yesBtn" onclick="yes()">aur koi option hai?</button>
          <button class="no" id="noBtn">no</button>
        </div>

      </div>
    </div>
  `);

  const no = document.getElementById("noBtn");
  const yesBtn = document.getElementById("yesBtn");
  const box = document.getElementById("finalBox");

  no.addEventListener("click", e => e.preventDefault());

  function moveNoBtn(){
    no.style.position = "absolute";

    const boxRect = box.getBoundingClientRect();
    const yesRect = yesBtn.getBoundingClientRect();
    const noRect  = no.getBoundingClientRect();

    const padding = 10;

    const maxX = box.clientWidth  - noRect.width  - padding;
    const maxY = box.clientHeight - noRect.height - padding;

    let randX, randY, overlap;

    do {
      randX = Math.random() * maxX;
      randY = Math.random() * maxY;

      const futureNo = {
        left: randX + boxRect.left,
        right: randX + boxRect.left + noRect.width,
        top: randY + boxRect.top,
        bottom: randY + boxRect.top + noRect.height
      };

      overlap = !(
        futureNo.right < yesRect.left ||
        futureNo.left  > yesRect.right ||
        futureNo.bottom < yesRect.top ||
        futureNo.top > yesRect.bottom
      );

    } while (overlap);

    no.style.left = randX + "px";
    no.style.top  = randY + "px";
  }

  no.addEventListener("mouseenter", moveNoBtn);
  no.addEventListener("mousedown", moveNoBtn);
  no.addEventListener("touchstart", moveNoBtn);
}

function yes(){
  hearts();
  render(`<div class="screen"><h1>ab toh fas gayi tum mere sath forever k liye! ðŸ’—</h1></div>`);
}

function hearts(){
  setInterval(()=>{
    const h=document.createElement("div");
    h.className="heart";
    h.innerText="ðŸ’—";
    h.style.left=Math.random()*100+"vw";
    document.body.appendChild(h);
    setTimeout(()=>h.remove(),4000);
  },300);
}
</script>

</body>
  <script>
(function(){
  const MAX_DECOS = 6;            // performance limit
  const SCROLL_HIDE_PX = 200;     // hide after user scrolls 200px
  const DECO_IDS = [];            // track created elements
  let hintEl = null;
  let hidden = false;
  let decoCreated = false;

  // Utility to create a decoration element
  function createDeco(side, sizeClass, topOffset) {
    const d = document.createElement('div');
    d.className = `cp-float-deco ${side} ${sizeClass}`;
    d.style.top = (topOffset || (30 + Math.random()*40)) + '%';
    // slight random animation delay so they don't move in sync
    d.style.animationDelay = (Math.random()*2) + 's';
    d.setAttribute('aria-hidden','true');
    document.body.appendChild(d);
    DECO_IDS.push(d);
    return d;
  }

  // Create a small set of floating decorations (left and right)
  function createDecorations() {
    if (decoCreated) return;
    decoCreated = true;

    // create up to MAX_DECOS, split left/right
    const half = Math.ceil(MAX_DECOS / 2);
    for (let i=0;i<half;i++){
      createDeco('cp-float-left', (i%2? 'cp-small':'cp-large'), 20 + i*8);
    }
    for (let i=0;i<MAX_DECOS-half;i++){
      createDeco('cp-float-right', (i%2? 'cp-small':'cp-large'), 22 + i*7);
    }
  }

  // Create the scroll hint and append to body
  function createScrollHint() {
    if (hintEl) return hintEl;
    hintEl = document.createElement('div');
    hintEl.className = 'cp-scroll-hint cp-bounce';
    hintEl.innerHTML = `<span class="cp-hint-text">Scroll down for more</span><span class="cp-hint-heart">ðŸ’—</span>`;
    hintEl.setAttribute('role','status');
    hintEl.setAttribute('aria-live','polite');
    document.body.appendChild(hintEl);
    return hintEl;
  }

  // Hide hint and decorations with fade and then remove listeners
  function hideHintAndDecos() {
    if (hidden) return;
    hidden = true;

    if (hintEl) hintEl.classList.add('cp-hidden');

    // fade decorations
    DECO_IDS.forEach(d => {
      if (d && d.style) {
        d.style.transition = 'opacity 420ms ease, transform 420ms ease';
        d.style.opacity = '0';
        // remove after transition
        setTimeout(()=>{ try{ d.remove(); }catch(e){} }, 520);
      }
    });

    // remove hint after transition
    setTimeout(()=>{ try{ if (hintEl) hintEl.remove(); }catch(e){} }, 520);

    // cleanup scroll listener
    window.removeEventListener('scroll', onScrollCheck, {passive:true});
  }

  // Scroll handler checks threshold
  function onScrollCheck() {
    const sc = window.scrollY || document.documentElement.scrollTop || 0;
    if (sc >= SCROLL_HIDE_PX) hideHintAndDecos();
  }

  // Observe DOM for the first memory screen to appear, then attach hint/decorations
  function observeForMemoryScreen() {
    // If memory-wrapper already present, attach immediately
    if (document.querySelector('.memory-wrapper') || document.getElementById('mem')) {
      createDecorations();
      createScrollHint();
      // attach scroll listener
      window.addEventListener('scroll', onScrollCheck, {passive:true});
      return;
    }

    // Otherwise watch for insertion
    const mo = new MutationObserver((mutations, obs) => {
      if (document.querySelector('.memory-wrapper') || document.getElementById('mem')) {
        createDecorations();
        createScrollHint();
        window.addEventListener('scroll', onScrollCheck, {passive:true});
        obs.disconnect();
      }
    });

    mo.observe(document.documentElement || document.body, {
      childList: true,
      subtree: true
    });

    // safety timeout: if nothing appears in 10s, create decorations anyway
    setTimeout(()=>{
      if (!decoCreated) {
        createDecorations();
        createScrollHint();
        window.addEventListener('scroll', onScrollCheck, {passive:true});
        mo.disconnect();
      }
    }, 10000);
  }

  // Start observing on DOMContentLoaded or immediately if already loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', observeForMemoryScreen);
  } else {
    observeForMemoryScreen();
  }

  // Expose a small API for manual control if needed (optional)
  window.__cpScrollHint = {
    show: () => { createDecorations(); createScrollHint(); },
    hide: hideHintAndDecos
  };
})();
</script>

</html>








































